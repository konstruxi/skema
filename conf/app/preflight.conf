
postgres_pass    database;
postgres_output  json;
postgres_query   ":WITH matches as (
    -- Find records with matching slugs

    SELECT * FROM kx_lookup(:first, :second, :third)
    UNION ALL
    SELECT null, '', ''
  )

  -- generate all possible slug/resource combinations
  SELECT *,
    table_name                             as resource_name,
    singularize(table_name)                as singular,
    '..' as back,
    :parent_id || 'a ' || :request_uri         as biggles,

    coalesce(third_updated_at, second_updated_at, first_updated_at) as last_modified,

    coalesce(nullif(:action, ''), 
      CASE WHEN :request_method = 'GET' THEN
        CASE WHEN :id = '' THEN
          'index'
        ELSE
          'show'
        END
      ELSE
        'post'
      END)                                as action,

    -- figure out relative path up one level
    CASE WHEN :request_method != 'GET' or :id = '' or :action != '' THEN 
      './'
    ELSE
      '../'
    END as back,

    -- find options for selects
    options_for(:resource, (CASE WHEN :request_method != 'GET' THEN
      'edit'
    ELSE 
      nullif(:action, '')
    END), columns) as options



    from  (SELECT first.resource    as first_resource,
                  first.slug        as first_slug,
                  first.updated_at  as first_updated_at,
                  second.resource   as second_resource,
                  second.slug       as second_slug,
                  second.updated_at as second_updated_at,
                  third.resource    as third_resource,
                  third.slug        as third_slug,
                  third.updated_at  as third_updated_at,
 
    concat_ws('/', nullif(first.resource, ''), 
                   nullif(second.resource, ''), 
                 nullif(third.resource, '')) as path, 
               * FROM matches first, matches second, matches third) f

    LEFT JOIN structures_and_services q

    -- match urls against resource structure
    ON (concat_ws('/', nullif(q.grandparent_name, ''), nullif(q.parent_name, ''), q.table_name) = path)

    where table_name != ''
      and first_slug = :first
      and second_slug = :second
      and third_slug = :third
      and (first_resource != second_resource or first_resource = '')
      and (second_resource != third_resource or second_resource = '')
      and (third_resource != second_resource or third_resource = '')

  ORDER BY last_modified DESC;
  ";

postgres_rewrite no_rows 404;

