
postgres_pass    database;
postgres_output  json;
postgres_query   ":WITH matches as (
    -- Find records with matching slugs

    SELECT * FROM kx_lookup(:slug3, :slug2, :slug)
    UNION ALL
    SELECT null, '', '', null
  )

  -- generate all possible slug/resource combinations
  SELECT q.*,
    table_name                             as resource_name,
    singularize(table_name)                as singular,
    'You!'     as biggles,
    f.third                                as third,
    f.second                               as second,
    f.first                                as resource,
    f.second_resource                      as second_resource,
    f.third_resource                       as third_resource,

    coalesce(first_updated_at, second_updated_at, third_updated_at) as last_modified,
    path,

    coalesce(nullif(:action, ''), 
      CASE WHEN :request_method = 'GET' THEN
        CASE WHEN :resource is null THEN
          'display'
        WHEN :slug is null THEN
          'index'
        ELSE
          'show'
        END
      ELSE
        'post'
      END)                                as action,

    -- figure out relative path up one level
    CASE WHEN :request_method != 'GET' or :slug = '' or :action != '' or :resource = '' THEN 
      './'
    ELSE
      '../'
    END as back,

    '../' as base,

    -- find options for selects
    options_for(:resource, (CASE WHEN :request_method != 'GET' THEN
      'edit'
    WHEN :action = 'edit' or :action = 'new' THEN
      :action
    END), columns) as options



    from  (SELECT third.resource    as third_resource,
                  third.slug        as third_slug,
                  third.updated_at  as third_updated_at,
                  second.resource   as second_resource,
                  second.slug       as second_slug,
                  second.updated_at as second_updated_at,
                  first.resource    as first_resource,
                  first.slug        as first_slug,
                  first.updated_at  as first_updated_at,

                  kx_clean_jsonb(third.jsonb) as third,
                  kx_clean_jsonb(second.jsonb) as second,
                  kx_clean_jsonb(first.jsonb) as first,
 
    concat_ws('/', nullif(third.resource, ''), 
                   nullif(second.resource, ''), 
                   nullif(first.resource, '')) as path, 
               * FROM matches third, matches second, matches first) f

    RIGHT JOIN kx_resources_and_services q

    ON (1=1)

    where (
      table_name != ''
      and third_slug = :slug3
      and second_slug = :slug2
      and first_slug = coalesce(:slug, '')
      and
      
      (CASE WHEN :resource != '' THEN
              concat_ws('/', nullif(q.grandparent_name, ''), nullif(q.parent_name, ''), q.table_name) 
            = concat_ws('/', nullif(:resource3, ''), nullif(:resource2, ''), :resource)
            WHEN concat_ws('/', nullif(q.grandparent_name, ''), nullif(q.parent_name, ''), q.table_name) = path THEN
              (third_resource != second_resource or third_resource = '')
              and (second_resource != first_resource)
              and (first_resource != second_resource)
            END)
            )
  ORDER BY length(path) DESC, last_modified DESC
  LIMIT 1;
  ";

postgres_rewrite no_rows 405;

