Chunks = {}
Chunks["actions/delete.sql"] = "-- Turns DELETEs into INSERTS with deleted_at timestamp\nCREATE OR REPLACE FUNCTION\ndelete_{resource}() returns trigger language plpgsql AS $$\n  begin\n    -- set deleted_at timestamp\n    EXECUTE 'UPDATE ' || TG_TABLE_NAME || ' SET deleted_at = now() WHERE id = $1' USING OLD.id;\n\n    return null; -- dont delete original row\n  end;\n$$;\n\nCREATE TRIGGER delete_{resource}\n    BEFORE DELETE ON {resources}\n    FOR EACH ROW EXECUTE PROCEDURE delete_{resource}();\n"

Chunks["actions/insert.sql"] = "-- Inserts new version of a row\nCREATE OR REPLACE FUNCTION\ncreate_{resource}() returns trigger language plpgsql AS $$ begin\n\n{if 'actions/patch'\n  -- merge over latest versions if given root_id\n  IF new.root_id is not NULL and new.version is NULL THEN\n    SELECT * FROM {resources} WHERE id = new.root_id or root_id = new.root_id ORDER BY id DESC LIMIT 1 INTO old;\n    new.created_at = old.created_at;\n    new.version = old.version + 1;\n    new.root_id = coalesce(old.root_id, new.root_id);\n{schema     new.$1 = coalesce(new.$1, old.$1);}    -- GENERATED: column names\n  END IF;\n}\n  new.errors = validate_{resource}(new);\n\n  return (\n    new.id,\n{if 'actions/patch'\n    coalesce(new.root_id, new.id),          -- inherit root_id or set to self\n    coalesce(new.version, 0),               -- start with 0 version unless given\n    new.previous_version,                   -- point to previous version\n    new.next_version,                       -- point to next version\n}\n    new.errors,\n    coalesce(new.created_at, now()),        -- inherit or set creation timestamp\n    coalesce(new.updated_at, now()),        -- inherit or set modification timestamp\n{if 'actions/delete'\n    new.deleted_at,                         -- inherit deletion timestamp\n} \n{schema     coalesce(new.$1, $3),});        -- GENERATED: column names & default values\nend $$;\n\nCREATE TRIGGER create_{resource}\n    BEFORE INSERT ON {resources}\n    FOR EACH ROW EXECUTE PROCEDURE create_{resource}();"

Chunks["actions/patch.sql"] = "-- Turns update into insert and bumps version\nCREATE OR REPLACE FUNCTION\nupdate_{resource}() returns trigger language plpgsql AS $$ begin\n  INSERT INTO {resources}(\n    root_id, version, previous_version, next_version, \n    created_at, updated_at, {if 'actions/delete' deleted_at,} \n{schema     $1,})                           -- GENERATED: column names\n  VALUES (\n    old.root_id,                            -- inherit root_id\n    {resource}_head(old.root_id, false) + 1,-- bump version to max + 1\n    CASE WHEN new.root_id = -1 THEN\n      old.previous_version\n    ELSE\n      old.version\n    END,\n    CASE WHEN new.next_version = old.next_version and new.root_id != -1 THEN\n      null\n    ELSE\n      new.next_version\n    END,\n    old.created_at,                         -- inherit creation timestamp \n    now(),                                  -- update modification timestamp\n  {if 'actions/delete'\n      new.deleted_at,                         -- inherit deletion timestamp\n  } \n{schema     new.$1,});                      -- GENERATED: column names\n\n  return null;                              -- keep row immutable\nend $$;\n\nCREATE TRIGGER update_{resource}\n    BEFORE UPDATE ON {resources}\n    FOR EACH ROW EXECUTE PROCEDURE update_{resource}();\n\n\n\n\n\n"

Chunks["actions/update.sql"] = "-- Validate on update\nCREATE OR REPLACE FUNCTION\nupdate_{resource}() returns trigger language plpgsql AS $$ begin\n  new.errors = validate_{resource}(new);\n  new.updated_at = now();\n  return new;\nend $$;\n\nCREATE TRIGGER update_{resource}\n    BEFORE UPDATE ON {resources}\n    FOR EACH ROW EXECUTE PROCEDURE update_{resource}();\n\n"

Chunks["helpers.sql"] = "CREATE OR REPLACE FUNCTION\nsingularize(text) returns text language plpgsql AS $$ begin\n  return regexp_replace(regexp_replace($1, 'ies$', 'y'), 's$', '');\nend $$;\n\n\nCREATE OR REPLACE FUNCTION\npluralize(text) returns text language plpgsql AS $$ begin\n    return case when $1 = '' then\n        ''\n    else\n        $1 || 's'\n    end;\nend $$;\n"

Chunks["queries.sql"] = "-- Returns SQL query that selects from specified table with related rows aggregated as json\nCREATE OR REPLACE FUNCTION full_select_sql(relname text, structure json)\n  RETURNS text AS\n$BODY$DECLARE\n ret json;\n names text;\n joins text;\nBEGIN\n\n  WITH cols as (select\n    value->>'name' as name,\n    replace(value->>'name', '_id', '') as prefix,\n    substr(value->>'name', 0, 2) as alias,\n    value\n  from json_array_elements(structure)\n  WHERE position('_ids' in value->>'name') = 0)\n\n  SELECT\n    string_agg(alias || '.json_agg as ' || prefix || 's', ',')\n    FROM cols\n    WHERE cols.name != 'root_id' and prefix != name\n    into names;\n\n\n  WITH cols as (select\n    value->>'name' as name,\n    replace(value->>'name', '_id', '') as prefix,\n    pluralize(replace(value->>'name', '_id', '')) as prefix_plural,\n    substr(value->>'name', 0, 2) as alias,\n    value\n  from json_array_elements(structure)\n  WHERE position('_ids' in value->>'name') = 0)\n\n  SELECT\n    string_agg(\n      'LEFT JOIN (SELECT ' || relname || '.id, json_agg(' || prefix_plural || ')\n       from ' || relname || ' \n       LEFT JOIN ' || prefix_plural || ' \n       ON (' || relname || '.' || name || ' = ' || prefix_plural || '.id) \n       GROUP BY ' || relname || '.id) ' || alias || ' \n       ON ' || alias || '.id = ' || relname || '.' || name, ',')\n    FROM cols\n    WHERE cols.name != 'root_id' and prefix != name\n    into joins;\n\n\n  RETURN 'SELECT ' || relname || '.* ' || (CASE WHEN names is not null THEN\n      ', ' || names\n    ELSE\n      ''\n    END) || ' from ' || relname || '_current as ' || relname || ' ' || coalesce(joins, '') || ' WHERE 1=1 ';\nEND;\n$BODY$\nLANGUAGE plpgsql VOLATILE;\n\n\n-- select possible parents\nCREATE OR REPLACE FUNCTION update_sql(relname text, structure json)\n  RETURNS text AS\n$BODY$DECLARE\n names text;\nBEGIN\n\n  SELECT\n    string_agg((els->>'name') || ' = coalesce(new.' || (els->>'name') || ', ' || relname || '.' || (els->>'name') || ')', ', ')\n    FROM json_array_elements(structure) els\n    into names;\n\n\n  RETURN 'UPDATE ' || relname || ' SET ' || names;\nEND;\n$BODY$\nLANGUAGE plpgsql VOLATILE;\n\n-- UPDATE as INSERT\nCREATE OR REPLACE FUNCTION patch_sql(relname text, structure json)\n  RETURNS text AS\n$BODY$DECLARE\n names text;\n values text;\nBEGIN\n\n  SELECT\n    string_agg(els->>'name', ', ')\n    FROM json_array_elements(structure) els\n    WHERE els->>'name' != 'id'\n    into names;\n\n  SELECT\n    string_agg(CASE WHEN els->>'name' = 'root_id' THEN\n      ':i:id'\n    ELSE\n      'new.' || (els->>'name')\n    END, ', ')\n    FROM json_array_elements(structure) els\n    WHERE els->>'name' != 'id'\n    into values;\n\n  RETURN 'INSERT INTO ' || relname || '(' || names || ') SELECT ' || values;\nEND;\n$BODY$\nLANGUAGE plpgsql VOLATILE;\n\n\n-- INSERT\nCREATE OR REPLACE FUNCTION insert_sql(relname text, structure json)\n  RETURNS text AS\n$BODY$DECLARE\n names text;\n values text;\nBEGIN\n\n  SELECT\n    string_agg(els->>'name', ', ')\n    FROM json_array_elements(structure) els\n    WHERE els->>'name' != 'id'\n    into names;\n\n  SELECT\n    string_agg('new.' || (els->>'name'), ', ')\n    FROM json_array_elements(structure) els\n    WHERE els->>'name' != 'id'\n    into values;\n\n  RETURN 'INSERT INTO ' || relname || '(' || names || ') SELECT ' || values;\nEND;\n$BODY$\nLANGUAGE plpgsql VOLATILE;\n\n\n\n\n\n"

Chunks["relations/parent.sql"] = "\nCREATE OR REPLACE \nVIEW {resources}_with_{target} AS\nSELECT * from {resources}_current;\n\n\n-- Serialized with json\nCREATE OR REPLACE \nVIEW {targets}_json AS\nSELECT {targets}.*, \n{targets}_{resources}.{resources}_objects as {resources}\nFROM {targets}_current {targets}\nLEFT JOIN (\n	SELECT {targets}.id, jsonb_agg({resources}) as {resources}_objects\n	FROM {targets}_current {targets} \n	INNER JOIN {resources}_json {resources}\n	ON ({targets}.root_id = {resources}.{target}_id) \n	GROUP BY {targets}.id\n) {targets}_{resources} \nON ({targets}_{resources}.id = {targets}.id);\n"

Chunks["relations/source.sql"] = "\nCREATE OR REPLACE \nVIEW {resources}_for_{target} AS\nSELECT * from {resources}_current;\n\n-- Create empty {resource} object\nCREATE OR REPLACE FUNCTION\ncreate_{resource}_for_{target}() returns trigger language plpgsql AS $$ begin\n  if (new.errors is not null) then\n    INSERT into {resources}_for_{target}({target}_id) VALUES(new.id);\n  END IF;\n  return new;\nend $$;\n\nCREATE TRIGGER create_{resource}_for_{target}\n    AFTER INSERT ON {targets}\n    FOR EACH ROW EXECUTE PROCEDURE create_{resource}_for_{target}();\n\n\n\n-- Serialized with json\nCREATE OR REPLACE \nVIEW {targets}_json AS\nSELECT {targets}.*, \n{targets}_{resources}.{resources}_objects as {resources}\nFROM {targets}_current {targets}\nLEFT JOIN (\n	SELECT {targets}.id, jsonb_agg({resources}) as {resources}_objects\n	FROM {targets}_current {targets} \n	INNER JOIN {resources}_json {resources}\n	ON ({targets}.root_id = {resources}.{target}_id) \n	GROUP BY {targets}.id\n) {targets}_{resources} \nON ({targets}_{resources}.id = {targets}.id);\n"

Chunks["schema.sql"] = "-- Example of a postgre-driven immutable versioned and validated models\n\nDROP TABLE {resources} CASCADE;\nCREATE TABLE {resources} (\n  id serial PRIMARY KEY,             -- Serial ID\n{if 'actions/patch'\n  root_id integer,                      -- ID of a first version\n  version integer,                      -- Version number\n  previous_version integer,             -- ID of a previous version\n  next_version integer,}\n  errors jsonb,                         -- Results of validation\n\n  created_at TIMESTAMP WITH TIME ZONE,  -- Initial creation time\n  updated_at TIMESTAMP WITH TIME ZONE,  -- Last time of update\n{if 'actions/delete'\n  deleted_at TIMESTAMP WITH TIME ZONE,} -- Datestamp of deletion (inherited)\n\n  \n{schema   $1 $2,}                       -- GENERATED: column types \n);\n\nCREATE OR REPLACE FUNCTION\nvalidate_{resource}(new {resources}) returns jsonb language plpgsql AS $$ declare\n  errors jsonb := '{}';\nbegin\n  -- GENERATED: column validations\n{schema   IF NOT (new.$1 $4) THEN\n    SELECT jsonb_set(errors, '{$1}', '\"$5\"') into errors;\n  END IF;}\n\n  if errors::text = '{}' THEN\n    errors = null;\n  END IF;\n\n  return errors;\nend $$;\n\n-- Scope: last versions\nCREATE OR REPLACE \nVIEW {resources}_heads AS \nSELECT * from {resources};\n\n-- Scope: undeleted things\nCREATE OR REPLACE \nVIEW {resources}_current AS \nSELECT * from {resources}_heads;\n\n-- Scope: undeleted things\nCREATE OR REPLACE \nVIEW {resources}_json AS \nSELECT * from {resources}_current;\n\n-- Scope: versions things\nCREATE OR REPLACE \nVIEW {resources}_versions AS \n\nSELECT *{if 'actions/update',, id as root_id} from {resources};\n"

Chunks["scopes/current.sql"] = "-- Scope: last non-deleted versions \nCREATE OR REPLACE \nVIEW {resources}_current AS \nSELECT * FROM {resources}_heads  WHERE deleted_at is null;\n\n-- Mark HEAD of an {resource} as deleted (dont need to know version number)\nCREATE OR REPLACE function\ndelete_current_{resource}() returns trigger\nlanguage plpgsql\nAS $$\n  begin\n    DELETE from {resources} WHERE id=old.id;\n    return null;\n  end;\n$$;\n\nCREATE TRIGGER delete_current_{resource}\n    INSTEAD OF DELETE ON {resources}_current\n    FOR EACH ROW EXECUTE PROCEDURE delete_current_{resource}();\n\n"

Chunks["scopes/heads.sql"] = "-- Scope: last versions \nCREATE OR REPLACE \nVIEW {resources}_heads AS \nSELECT DISTINCT ON (root_id) * from {resources}_versions;\n\n-- Find last version of an row, optionally may return invalid version too\nCREATE OR REPLACE FUNCTION {resource}_head(integer, boolean DEFAULT true, integer DEFAULT 2147483646) RETURNS integer\n    AS 'SELECT version from {resources}  WHERE root_id = $1 and version < $3 and \n       case when $2 then errors is null else true end \n       ORDER BY version DESC'\n    LANGUAGE SQL IMMUTABLE RETURNS NULL ON NULL INPUT;\n\n-- DELETE from {resources}_heads -- Roll back to version\nCREATE OR REPLACE \nFUNCTION delete_{resource}_head() returns trigger language plpgsql AS $$ begin\n  DELETE from {resources}_versions WHERE id=old.id;\n  return null;\nend; $$;\n\nCREATE TRIGGER delete_{resource}_head\n    INSTEAD OF DELETE ON {resource}s_heads\n    FOR EACH ROW EXECUTE PROCEDURE delete_{resource}_head();\n\n\n-- UPDATE {resources}_heads      -- Set any version\nCREATE OR REPLACE \nFUNCTION update_{resource}_head() returns trigger language plpgsql AS $$ declare\n  next integer := {resource}_head(new.root_id, true, coalesce(new.next_version, old.version) + 1);\nbegin\n  UPDATE {resources} SET updated_at=now(), root_id=-1 WHERE version=next;\n  return null;\nend; $$;\n\nCREATE TRIGGER update_{resource}_head\n    INSTEAD OF UPDATE ON {resources}_heads\n    FOR EACH ROW EXECUTE PROCEDURE update_{resource}_head();\n"

Chunks["scopes/versions.sql"] = "-- Scope: history of changes\nCREATE OR REPLACE \nVIEW {resources}_versions AS \nSELECT * from {resources} WHERE errors is null ORDER BY root_id, version DESC;\n\n-- DELETE from {resources}_versions -- Roll back to version previous to deleted\nCREATE OR REPLACE function\ndelete_{resource}_version() returns trigger\nlanguage plpgsql\nAS $$\n  declare\n    prev integer := {resource}_head(old.root_id, true, old.previous_version + 1);\n    next integer := (SELECT next_version from {resources} WHERE version=prev and root_id = old.root_id);\n  begin\n    -- if there is no valid version to roll back to, mark as deleted if it isnt yet\n    IF prev is null and old.deleted_at is null THEN\n      DELETE FROM {resources}_current WHERE id=old.id;\n    ELSE\n      \n      -- otherwise clone preceeding version without deletion flag and make it current\n      UPDATE {resources} SET deleted_at=null, next_version=coalesce(next, old.version), root_id=-1\n      WHERE root_id = old.root_id and version=coalesce(prev, old.version);\n    END IF;\n    return null;\n  end;\n$$;\n\nCREATE TRIGGER delete_{resource}_version\n    INSTEAD OF DELETE ON {resources}_versions\n    FOR EACH ROW EXECUTE PROCEDURE delete_{resource}_version();\n"

Chunks["specs/target.sql"] = ""

Chunks["specs/versioning.sql"] = "INSERT into {resources}({field}{extra_columns})  VALUES({'invalid1'}{extra_values});\n{assert 'v0 insert initial invalid version',\nversion=0 and root_id=1 and {field}={'invalid1'} and errors->>{'field'} is not null and deleted_at is null and previous_version is null and next_version is null}\n\nUPDATE {resources} SET {field}={'valid1'} WHERE {field}={'invalid1'};\n{assert 'v1 Update initial invalid version into valid',\nversion=1 and root_id=1 and {field}={'valid1'} and errors->>{'field'} is null and deleted_at is null and previous_version = 0 and next_version is null}\n\nUPDATE {resources} SET {field}={'invalid2'} WHERE {field}={'valid1'};\n{assert 'v2 Turn valid version into invalid',\nversion=2 and root_id=1 and {field}={'invalid2'} and errors->>{'field'} is not null and deleted_at is null and previous_version = 1 and next_version is null}\n\nUPDATE {resources} SET {field}={'valid2'} WHERE version=2;\n{assert 'v3 Turn invalid version into valid again',\nversion=3 and root_id=1 and {field}={'valid2'} and errors->>{'field'} is null and deleted_at is null and previous_version = 2 and next_version is null}\n\nDELETE from {resources}_current;\n{assert 'v4 Soft delete of valid version',\nversion=4 and root_id=1 and {field}={'valid2'} and errors->>{'field'} is null and deleted_at is not null and previous_version = 3 and next_version is null}\n\nDELETE from {resources}_heads;\n{assert 'v5 Soft undelete',\nversion=5 and root_id=1 and {field}={'valid2'} and errors->>{'field'} is null and deleted_at is null and previous_version = 2 and next_version = 4}\n\nUPDATE {resources} SET {field}={field} ||'p' WHERE version=5;\n{assert 'v6 Append to versioned field',\nversion=6 and root_id=1 and {field}={'valid2'} || 'p' and errors->>{'field'} is null and deleted_at is null and previous_version = 5 and next_version is null}\n\nDELETE from {resources}_versions WHERE version=4;\n{assert 'v7 Roll back more than one version (to v3)',\nversion=7 and root_id=1 and {field}={'valid2'} and errors->>{'field'} is null and deleted_at is null and previous_version = 2 and next_version = 4}\n\nDELETE from {resources}_heads;\n{assert 'v8 Roll back skipping invalid version',\nversion=8 and root_id=1 and {field}={'valid1'} and errors->>{'field'} is null and deleted_at is null and previous_version = 0 and next_version = 7}\n\nDELETE from {resources}_heads;\n{assert 'v9 No valid version to roll back, mark as deleted',\nversion=9 and root_id=1 and {field}={'valid1'} and errors->>{'field'} is null and deleted_at is not null and previous_version = 8 and next_version is null}\n\nDELETE from {resources}_heads;\n{assert 'v10 Undelete version that couldnt roll back',\nversion=10 and root_id=1 and {field}={'valid1'} and errors->>{'field'} is null and deleted_at is null and previous_version = 0 and next_version = 7}\n\n-- version 11 valid   -- redo applies 7th step\nUPDATE {resources}_heads SET version = next_version WHERE root_id=1 and next_version is not null;\nUPDATE {resources}_heads SET version = next_version WHERE root_id=1 and next_version is not null;\nUPDATE {resources}_heads SET version = next_version WHERE root_id=1 and next_version is not null;\nDELETE from {resources}_heads;\nDELETE from {resources}_heads;\n--DELETE from {resources}_heads;\n--UPDATE {resources}_heads SET version = next_version WHERE root_id=1 and next_version is not null;\n--\n---- one extra valid order\n--INSERT into {resources}({field})  VALUES('valid@c.com');\n---- one extra invalid order\n--INSERT into {resources}({field})  VALUES('d.com');\n\n-- 2 current valid {resources}\nSELECT * from {resources}_current;\n-- 11 + 1 + 1 versions\nSELECT * from {resources} ORDER BY id;\n{assert 'Should create 16 versions' max(version) = 15}\n\n\nCREATE OR REPLACE\nVIEW orders_json AS\nSELECT orders.*,\norders_items.items_json as items\nFROM orders_current orders\nLEFT JOIN (\n	SELECT orders.id order_idz, jsonb_agg(items) as items_json\n	FROM orders_current orders\n	INNER JOIN items_json items\n	ON (orders.root_id = items.order_id)\n	GROUP BY orders.id\n) orders_items\nON (orders_items.order_idz = orders.id);\n\n\n\nSELECT * from orders_json;"

Chunks["structures.sql"] = "\n\n-- enumerate user defined tables\nCREATE OR REPLACE VIEW structures AS\n\nSELECT  \n    columns.table_name,\n    json_agg(json_strip_nulls(row_to_json(columns))) as columns\n\nFROM (\n  SELECT \n  tables.table_name                                as table_name,\n  ''                                               as parent_name,\n  ''                                               as grandparent_name,\n  column_name                                      as name,\n  CASE WHEN position('_ids' in column_name) > 0\n  THEN replace(column_name, '_ids', '')\n  WHEN position('_id' in column_name) > 0\n  THEN pluralize(replace(column_name, '_id', ''))\n  END                                              as relation_name,\n  CASE WHEN position('character' in data_type) > 0\n  THEN 'string'\n  ELSE lower(data_type) END                               as type,\n  character_maximum_length                         as maxlength,\n  --(CASE WHEN position('_id' in column_name) > 0 and position('root_id' in column_name) = 0 THEN\n  --   json_from(replace(column_name, '_id', ''), v.value::text::int)->'json_agg'\n  -- END)                                            as options,\n  (column_name != 'id' and column_name != 'root_id' and \n   position('version' in column_name) = 0) or NULL as is_editable,\n  (position('_id' in column_name) > 0)\n  and column_name != 'root_id' or NULL              as is_select,\n  (SELECT c.column_name FROM INFORMATION_SCHEMA.COLUMNS c\n    WHERE c.table_name = tables.table_name\n    AND (position('character' in c.data_type) > 0 or c.data_type = 'text') LIMIT 1) = column_name or NULL  as is_title\n\nFROM INFORMATION_SCHEMA.COLUMNS\n\nLEFT JOIN INFORMATION_SCHEMA.TABLES tables\non tables.table_name = columns.table_name\n\nWHERE position('pg_' in tables.table_name) = 0 \nand tables.is_insertable_into != 'NO' \nAND position('sql_' in tables.table_name) != 1 \nand tables.table_type != 'VIEW'\n\n) columns\n\nGROUP BY columns.table_name;\n\n-- compute json array of tables that reference other table \nCREATE OR REPLACE VIEW structures_and_references AS\nSELECT \n    q.*, \n    x.refs as references\nFROM structures q\n\nLEFT JOIN(\n  SELECT structures.table_name, json_agg(y) as refs\n  FROM structures\n  INNER JOIN structures y\n  ON (EXISTS(SELECT value FROM json_array_elements(y.columns) WHERE \n      value->>'name' =(singularize(structures.table_name) || '_id') OR\n      value->>'name' = structures.table_name || '_ids'))\n  GROUP BY structures.table_name\n) x ON (x.table_name = q.table_name);\n\n\n\n-- compute json array of related tables for each table \nCREATE OR REPLACE VIEW structures_and_children AS\nSELECT \n    q.*, \n    s.relations as relations\n\nFROM structures_and_references q\n\nLEFT JOIN (\n  SELECT \n\n    structs.table_name, \n    pluralize(replace(value->>'name', '_id', '')) as relation,\n    row_to_json(x) as relations\n    \n    from structures structs, json_array_elements(structs.columns) as rls\n    \n\n  LEFT JOIN (\n    SELECT z.table_name, json_agg(z.columns) as columns\n    FROM (\n      SELECT * FROM structures \n    ) z\n    GROUP BY z.table_name\n  ) x\n  ON (x.table_name = pluralize(replace(value->>'name', '_id', '')) or \n      x.table_name = replace(value->>'name', '_ids', ''))\n\n  WHERE position('_id' in rls.value->>'name') > 0 \n    and rls.value->>'name' != 'root_id'\n\n) s\nON (q.table_name = s.table_name);\n\n-- produce configuration for nested resources\n-- by duplicating tables for each relation\nCREATE OR REPLACE VIEW structures_hierarchy AS\nSELECT \nstructures.*,\npluralize(replace(parent.column_name, '_id', ''))  as parent_name,\npluralize(replace(grandparent.column_name, '_id', ''))             as grandparent_name,\n\n(SELECT columns \n  from structures q \n  where table_name = pluralize(replace(parent.column_name, '_id', ''))\n  LIMIT 1) as parent_structure, \n\n(SELECT columns \n  from structures q \n  where table_name = pluralize(replace(grandparent.column_name, '_id', ''))\n  LIMIT 1) as grandparent_structure\n\nFROM structures_and_children structures\n\nLEFT JOIN (\n  SELECT column_name, columns.table_name\n  from INFORMATION_SCHEMA.COLUMNS columns\n  UNION SELECT '', ''\n) parent\non ((structures.table_name = parent.table_name\n  AND position('_id' in parent.column_name) > 0\n  AND position('_ids' in parent.column_name) = 0\n  AND parent.column_name != 'root_id')\n  or parent.table_name = '' )\n\n\nLEFT JOIN (\n  SELECT column_name, columns.table_name\n  from INFORMATION_SCHEMA.COLUMNS columns\n  UNION SELECT '', ''\n) grandparent\non ((pluralize(replace(parent.column_name, '_id', '')) = grandparent.table_name\n  AND (position('_id' in grandparent.column_name) > 0 \n    AND position('_ids' in grandparent.column_name) = 0) \n  AND grandparent.column_name != 'root_id')\n  or grandparent.table_name = '');\n\n\nDROP MATERIALIZED VIEW structures_and_queries;\n\nCREATE MATERIALIZED VIEW structures_and_queries AS\n  SELECT *, \n  CASE WHEN structures.parent_name != '' THEN\n    replace(full_select_sql(table_name, structures.columns), 'WHERE 1=1', 'WHERE ' || singularize(parent_name) || '_id = $parent_id')\n  ELSE\n    full_select_sql(table_name, structures.columns) \n  END as select_sql,\n  update_sql(table_name, structures.columns) AS update_sql,\n  patch_sql(table_name, structures.columns)  AS patch_sql,\n  insert_sql(table_name, structures.columns) AS insert_sql,\n  (table_name = 'services')                  AS initialized\n  \n  FROM structures_hierarchy structures;\n\n\n\n\nCREATE OR REPLACE FUNCTION delete_and_return_new(relname text, id integer)\n  RETURNS json AS\n$BODY$DECLARE\n  ret RECORD;\n  root_id integer;\nBEGIN\n  \n  EXECUTE 'SELECT root_id FROM ' || quote_ident(relname) || '_versions WHERE id=$1'\n    INTO root_id USING id;\n  \n  EXECUTE 'DELETE FROM ' || quote_ident(relname) || '_versions  WHERE id=$1 RETURNING *'\n    INTO ret USING id;\n  \n  EXECUTE 'SELECT * FROM ' || quote_ident(relname) || '_current  WHERE root_id=$1'\n    INTO ret USING root_id;\n\n  RETURN row_to_json(ret);\nEND;\n$BODY$\nLANGUAGE plpgsql VOLATILE;\n\n\nCREATE OR REPLACE FUNCTION options_for(relname text, preset text, structure json) RETURNS json language plpgsql AS $$ declare\n  options json := '{}';\nBEGIN\n    IF preset != 'edit' and preset != 'new'   THEN \n      return '{}'::json;\n    END IF;\n\n    WITH cols as (select\n      value->>'name' as name,\n      value\n    from json_array_elements(structure))\n\n    SELECT\n      json_object_agg(cols.name,\n      case when position('_ids' in cols.name) > 0 THEN\n        json_from(replace(cols.name, '_ids', '') || '_current')\n      when position('_id' in cols.name) > 0 THEN\n        json_from(pluralize(replace(cols.name, '_id', '')) || '_current')\n      end)\n      FROM cols \n      WHERE cols.name != 'root_id'\n      INTO options;\n\n    return options;\nEND $$;\n\n\n\n--SELECT *, o.json_agg as orders, p.json_agg as other\n--  FROM orders \n--\n--  LEFT JOIN (SELECT items.id, json_agg(orders) from items LEFT JOIN orders ON (items.order_id = orders.id) GROUP BY items.id) o \n--  ON o.id = orders.id\n--\n--  LEFT JOIN (SELECT items.id, json_agg(orders) from items LEFT JOIN orders ON (items.order_id = orders.id) GROUP BY items.id) p \n--  ON p.id = orders.id;\n\n\nCREATE OR REPLACE FUNCTION convert_arrays(input json)\n  RETURNS json language sql AS $ff$ \n    SELECT concat('{', string_agg(to_json(\"key\") || ':' || \n           (CASE WHEN value::text ~ '^\[[^\]\{\}]+\]$' THEN\n                -- convert arrays to psql array strings\n                regexp_replace(\n                  -- remove newlines\n                  regexp_replace(\n                    -- escape double quotes to adhere json syntax\n                    regexp_replace(value::text,\n                      '\"', '\\\"', 'g'),\n                   '\n', ' ', 'g'),\n                '^\[([^\]]+)\]$', '\"{\1}\"')\n            ELSE\n              value::text\n            END)\n      , ','), '}')::json\n    FROM json_each(input)\n\n$ff$;\n\n\nCREATE OR REPLACE FUNCTION insert_nested_object(name text, input json)\nRETURNS json language plpgsql as $ff$DECLARE\n ret json;\n columns text;\n BEGIN\n\n  SELECT\n    string_agg(key::text, ', ')\n    FROM json_each(input)\n    WHERE key::text != 'id'\n    into columns;\n\n  EXECUTE 'WITH r AS (INSERT INTO ' || name || '(' || columns || ') SELECT ' || columns || ' FROM json_populate_record(null::'||name||', $1) RETURNING *) SELECT row_to_json(r) FROM r' USING input  \n  INTO ret;\n  RETURN ret  ;\nEND;$ff$;\n\nCREATE OR REPLACE FUNCTION insert_nested_objects(name text, input json)\nRETURNS json language sql as $ff$\n  SELECT json_agg(insert_nested_object(name, value)) FROM json_array_elements(input)\n$ff$;\n\nCREATE OR REPLACE FUNCTION process_nested_attributes(input json)\n  RETURNS json language sql AS $ff$ \n    SELECT concat('{', string_agg(to_json(\"key\") || ':' || \n      (CASE WHEN value::text ~ '^\[[\s\n]*\{.*\}[\s\n]*\]$' THEN\n          insert_nested_objects(key::text, value)::text\n        ELSE\n          value::text\n        END)\n      , ','), '}')::json\n    FROM json_each(input)\n\n$ff$;\n\n\n-- select possible parents\nCREATE OR REPLACE FUNCTION json_from(relname text)\n  RETURNS json AS\n$BODY$DECLARE\n ret json;\n inputstring text;\nBEGIN\n\n  EXECUTE 'SELECT json_agg(r) FROM ( SELECT * FROM '|| quote_ident(relname) || ') r'\n  INTO ret;\n  RETURN ret  ;\nEND;\n$BODY$\nLANGUAGE plpgsql VOLATILE;\n\n\n"

